/**
 * ## 미지의 것
 * 일렬로 서 있는 학생의 키가 앞의 순서대로 주어졌을 때, 맨 앞에 서 있는 선생님이 볼 수 있는 학생의 수를 구하라
 *
 * ## 자료
 * 학생의 키
 * 선생님이 볼 수 있는 학생의 수
 *
 * ## 조건
 * 학생의 키가 순서대로 주어진다
 * 앞에 서 있는 사람보다 크면 보이고 작거나 같으면 보이지 않는다.
 *
 * ## 계획
 * 1. 나열 된 학생의 키 수를 입력 받는다.
 * 2. 나열 된 학생의 첫번째 자리수를 최댁값에 저정한다.
 * 3. 2번째 자리부터 나열 된 학생의 수의 길이 만큼 탐색을 한다.
 * 4. i 자리보다 max 수가 크면 결과는 i++ 하고 max에 i자리의 값을 저장한다.
 * 5. 탐색이 끝나면 결과값을 반환한다.
 *
 * ## 반성
 * max 값에 저장하고 탐색을 저장할 때마다 max 값을 갱신하면서 값을 비교하는 알고리즘을 떠올리면 쉽게 풀 수 있다는 것을 알게되었다.
 */

const solution = (students) => {
  let result = 1;
  let max = students[0];
  for (let i = 1; i < students.length; i++) {
    if (students[i] > max) {
      result++;
      max = students[i];
    }
  }

  return result;
};

describe('보이는 학생', () => {
  context('나열된 학생의 키가 주어지면', () => {
    it('맨 앞에서 선생님이 볼 수 있는 학생의 수를 구하라', () => {
      expect(
        solution([130, 135, 148, 140, 145, 150, 150, 153]),
      ).toBe(5);
    });
  });
});
